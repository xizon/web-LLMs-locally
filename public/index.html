<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
    <style>
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    margin: 0;
    padding: 20px;
}

.chat-container {
    max-width: 600px;
    margin: auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    padding: 20px;
}

.messages {
    height: 300px;
    overflow-y: auto;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 10px;
    font-size: 13px;
}

.messages > div {
    margin: 5px 0;
    padding: 3px 5px;
    background: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 0.35rem;
}
.messages p {
    margin: 3px 0;
}
.msgcontrol {
    display: flex;
}

.messages .timestamp {
    display: block;
    color: #979797;
    text-align: right;
}

input[type="text"] {
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

button {
    padding: 10px;
    border: none;
    background-color: #28a745;
    color: white;
    border-radius: 4px;
    cursor: pointer;
    margin-left: .5rem;
}

button:hover {
    background-color: #218838;
}

.loading {
    margin-top: .2rem;
}
    </style>

</head>

<body>
    <div id="test"></div>
    <div class="chat-container">
        <div id="messages" class="messages"></div>
        <div class="msgcontrol">
            <input type="text" id="messageInput" placeholder="Type your message here..." />
            <button id="sendButton">Send</button>
        </div>
        <div class="loading" id="loading" style="display: none;"><small>Loading...</small></div> 

    </div>

    <script src="axios.min.js"></script>
    <script src="marked.min.js"></script>
<script>

const messages = []; // Array to hold messages

async function fetchPost(msg) {

    // Default
    //======================
    let  _data = null;
    const res = await axios.post(`http://localhost:3000/api/generate`, {
        prompt: msg
    }).catch(function (error) {
        console.log(error);
    });

    if (res && res.status == 200) _data = res.data;

    return _data;


    // if stream is true, for browser (ollama's API)
    //======================
    // const response = await fetch(`http://localhost:11434/api/generate`, {
    //     method: 'POST',
    //     headers: {
    //         'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify({
    //         model: modelName.current,
    //         prompt: msg,
    //         stream: true
    //     }),
    // });

    // return response;

}

const sendButton = document.getElementById('sendButton');
const messageInput = document.getElementById('messageInput');
const loadingDiv = document.getElementById('loading');

const sendMessage = async () => {
    const message = messageInput.value;

    if (message.trim() === '') {
        return;
    }

    // User message
    const inputMsg = `${message}`;
    const timeStart = new Date().toLocaleTimeString(); // Get the current time
    messages.push({ sender: 'Me', type: 'send', timestamp: timeStart, content: inputMsg }); // Add user message to array
    renderMessages(); // Render messages

    // Loading
    loadingDiv.style.display = 'inline-block';

    // clear
    messageInput.value = '';

    try {
        const res = await fetchPost(message);
        const timeEnd = new Date().toLocaleTimeString(); // Get the current time

        console.log(res);

        // loading
        loadingDiv.style.display = 'none';


        // reply (normal)
        //======================
        const reply = res.reply;
        const replyRes = `${reply}`;
        const outMsg = marked.parse(replyRes);
        messages.push({ sender: 'AI', type: 'reply', timestamp: timeEnd, content: outMsg }); // Add AI reply to array
        renderMessages(); // Render messages


        // stream
        //======================
        // const reader = res.body.getReader();
        // const decoder = new TextDecoder();
        // let done = false;
        // let partialText = '';
        // let jsonData = '';

        // const streamHandler = async () => {
        //     while (!done) {
        //         const { value, done: doneReading } = await reader.read();
        //         done = doneReading;
                
        //         const text = decoder.decode(value, { stream: true });
        //         jsonData += text;
                
        //         try {
        //             while (jsonData) {
        //                 const endOfJSON = jsonData.indexOf('}');
        //                 if (endOfJSON !== -1) {
        //                     const validJson = jsonData.slice(0, endOfJSON + 1);
        //                     jsonData = jsonData.slice(endOfJSON + 1);

        //                     const parsedData = JSON.parse(validJson);

        //                     // update to div
        //                     partialText += parsedData.response;
        //                 } else {
        //                     break;
        //                 }
        //             }
        //         } catch (e) {
        //             console.error('JSON parsing error: ', e);
        //         }

        //     }
        // };

        // streamHandler();

        
    } catch (error) {

        // loading
        loadingDiv.style.display = 'none';
        
        console.error('Error sending message:', error);
        messages.push({ sender: 'Error', type: 'reply', timestamp: timeStart, content: `Error: Unable to send message: ${error}` }); // Add error message to array
        renderMessages(); // Render messages
    }

};
const debouncedSendMessage = debounce(sendMessage, 300);

function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

function typewriterEffect(element, str, speed = 50) {
    if (!element) return;

    const originalHTML = str;
    element.innerHTML = '';

    let cursor = 0;
    let tempHTML = '';
    const tagStack = [];

    function type() {
        if (cursor >= originalHTML.length) {
            // Clear the cursor after typing is complete
            element.innerHTML = tempHTML; // Set the final content without the cursor
            return;
        }

        const currentChar = originalHTML[cursor];

        if (currentChar === '<') {
            const closeTagIndex = originalHTML.indexOf('>', cursor);
            const tagContent = originalHTML.slice(cursor, closeTagIndex + 1);
            tempHTML += tagContent;

            // Handle opening and closing tags
            if (/^<\/?\w+/.test(tagContent)) {
                if (!/^<\//.test(tagContent)) {
                    // Opening tag
                    tagStack.push(tagContent);
                } else {
                    // Closing tag
                    tagStack.pop();
                }
            }

            cursor = closeTagIndex + 1;
        } else {
            tempHTML += currentChar;
            cursor++;
        }

        element.innerHTML = tempHTML + '<span class="cursor">|</span>'; // Show cursor
        setTimeout(type, speed);
    }

    type();
}


function renderMessages() {
    const messagesDiv = document.getElementById('messages');
    messagesDiv.innerHTML = ''; // Clear existing messages
    messages.forEach((msg, index) => {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add(msg.type);
        messageDiv.innerHTML = `<strong>${msg.sender}:</strong> <div class="content">${msg.content}</div> <span class="timestamp">${msg.timestamp}</span>`;
        messagesDiv.appendChild(messageDiv);

        if (msg.type === 'reply' && index === messages.length - 1) {
            typewriterEffect([].slice.call(messagesDiv.querySelectorAll('.reply')).at(-1).querySelector('.content'), msg.content, 10);
        }
    });
    messagesDiv.scrollTop = messagesDiv.scrollHeight; // Scroll to the bottom
}
sendButton.addEventListener('click', debouncedSendMessage);

messageInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
        event.preventDefault();
        debouncedSendMessage();
    }
});

</script>

    
</body>

</html>